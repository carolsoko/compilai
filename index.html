<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compilaí v3.2</title>
    <meta name="description" content="Compilador Web de Portugol com 99.17% de compatibilidade com VisuAlG.">
    
    <!-- Editor Monaco -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fontes do Google -->
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Ícones Lucide -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>

    <style>
        :root {
            --editor-bg: hsl(210, 11%, 12%);
            --editor-sidebar: hsl(216, 12%, 15%);
            --editor-border: hsl(215, 14%, 25%);
            --editor-text: hsl(210, 11%, 83%);
            --editor-accent: hsl(207, 100%, 40%);
            --editor-success: hsl(158, 64%, 62%);
            --editor-warning: hsl(45, 93%, 69%);
            --editor-error: hsl(351, 92%, 62%);
            --editor-comment: hsl(114, 31%, 58%);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--editor-bg);
            color: var(--editor-text);
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .editor-sidebar {
            background-color: var(--editor-sidebar);
        }

        .editor-border {
            border-color: var(--editor-border);
        }

        .editor-text {
            color: var(--editor-text);
        }

        .editor-accent {
            background-color: var(--editor-accent);
        }

        .editor-success {
            background-color: var(--editor-success);
        }

        .editor-warning {
            background-color: var(--editor-warning);
            color: var(--editor-bg);
        }

        .editor-error {
            background-color: var(--editor-error);
        }

        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid var(--editor-border);
            background-color: var(--editor-sidebar);
            color: var(--editor-text);
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: var(--editor-bg);
        }

        .btn-primary {
            background-color: var(--editor-accent);
            color: white;
            border-color: var(--editor-accent);
        }

        .btn-primary:hover {
            opacity: 0.8;
        }

        .btn-error {
            background-color: var(--editor-error);
            color: white;
            border-color: var(--editor-error);
        }

        .btn-success {
            background-color: var(--editor-success);
            color: white;
            border-color: var(--editor-success);
        }

        .btn-warning {
            background-color: var(--editor-warning);
            color: var(--editor-bg);
            border-color: var(--editor-warning);
        }

        .card {
            background-color: var(--editor-sidebar);
            border: 1px solid var(--editor-border);
            border-radius: 8px;
            padding: 16px;
            margin: 8px;
        }

        .output-container {
            background-color: #ffffff;
            color: #000000;
            border: 1px solid var(--editor-border);
            border-radius: 6px;
            padding: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            max-height: 560px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .error-line {
            color: var(--editor-error);
            background-color: rgba(var(--editor-error), 0.1);
            padding: 4px 8px;
            border-left: 3px solid var(--editor-error);
            margin: 2px 0;
        }

        .success-line { color: #000000; }

        .tab-button {
            padding: 8px 16px;
            border: none;
            background-color: var(--editor-bg);
            color: var(--editor-text);
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            transition: all 0.2s;
        }

        .tab-button.active {
            background-color: var(--editor-accent);
            color: white;
        }

        .tab-button:hover {
            background-color: var(--editor-sidebar);
        }

        .compatibility-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .feature-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background-color: var(--editor-bg);
            border: 1px solid var(--editor-border);
            border-radius: 6px;
        }

        .feature-implemented {
            color: var(--editor-success);
        }

        .feature-missing {
            color: var(--editor-error);
        }

        .badge {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        .badge-success {
            background-color: var(--editor-success);
            color: white;
        }

        .badge-warning {
            background-color: var(--editor-warning);
            color: var(--editor-bg);
        }

        .badge-error {
            background-color: var(--editor-error);
            color: white;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: var(--editor-bg);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--editor-success);
            transition: width 0.3s ease;
        }

        #monaco-container {
            border: 1px solid var(--editor-border);
            border-radius: 6px;
            overflow: hidden;
        }

        .header {
            background-color: var(--editor-sidebar);
            border-bottom: 1px solid var(--editor-border);
            padding: 16px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background-color: var(--editor-accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
        }

        .logo-img {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            object-fit: cover;
            display: block;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            padding: 16px;
            min-height: calc(100vh - 80px);
        }

        .editor-panel {
            display: flex;
            flex-direction: column;
        }

        .output-panel {
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: between;
            margin-bottom: 16px;
            padding: 12px 16px;
            background-color: var(--editor-sidebar);
            border: 1px solid var(--editor-border);
            border-radius: 6px;
        }

        .panel-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--editor-text);
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 16px;
            padding: 16px;
            background-color: var(--editor-bg);
            border: 1px solid var(--editor-border);
            border-radius: 6px;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--editor-border);
            margin-bottom: 16px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        /* Modal para fila de entrada */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal {
            width: min(720px, 92vw);
            background: var(--editor-bg);
            border: 1px solid var(--editor-border);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            color: var(--editor-text);
        }
        .modal-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--editor-border);
            font-weight: 600;
        }
        .modal-body {
            padding: 16px;
        }
        .modal-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            padding: 12px 16px;
            border-top: 1px solid var(--editor-border);
        }
    </style>
</head>
<body>
    <!-- Cabeçalho -->
    <header class="header">
        <div class="logo">
            <img src="https://raw.githubusercontent.com/carolsoko/imagens/main/compilai.png" alt="Compilaí" class="logo-img">
            <div>
                <h1 style="margin: 0; font-size: 24px; font-weight: 700;">Compilaí v3.2</h1>
            </div>
        </div>
        <div class="badge badge-success">99,17% Compatível com VisuALG</div>
    </header>

    <!-- Container Principal -->
    <div class="main-container">
        <!-- Painel do Editor -->
        <div class="editor-panel">
            <div class="panel-header">
                <h2 class="panel-title">Editor de Código Portugol</h2>
            </div>
            
            <div id="monaco-container" style="height: 500px;"></div>
            
            <div class="controls">
                <button id="btn-execute" class="btn btn-primary">
                    <i data-lucide="play"></i> Executar
                </button>
                <button id="btn-stop" class="btn btn-error" style="display: none;">
                    <i data-lucide="square"></i> Parar
                </button>
                <button id="btn-clearCod" class="btn">
                    <i data-lucide="trash-2"></i> Limpar Código
                </button>
                <button id="btn-clear" class="btn">
                    <i data-lucide="trash-2"></i> Limpar Saída
                </button>
                <button id="btn-debug" class="btn">
                    <i data-lucide="bug"></i> Debug
                </button>
                <button id="btn-example" class="btn">
                    <i data-lucide="file-text"></i> Exemplo
                </button>
                <div style="margin-left: auto;">
                    <span id="status" class="badge">Pronto</span>
                </div>
            </div>

            
        </div>

        <!-- Painel de Saída/Análise -->
        <div class="output-panel">
            <div class="tabs">
                <button class="tab-button active" data-tab="output">
                    <i data-lucide="terminal"></i> Saída
                </button>
                <button class="tab-button" data-tab="compatibility">
                    <i data-lucide="check-circle"></i> Compatibilidade
                </button>
            </div>

            <!-- Aba de Saída -->
            <div id="tab-output" class="tab-content active">
                <div class="panel-header">
                    <h2 class="panel-title">Saída do Programa</h2>
                    <span id="execution-time" class="badge" style="display: none;"></span>
                </div>
                <div id="output-container" class="output-container">
                    Execute um programa para ver a saída aqui...
                </div>
            </div>

            <!-- Aba de Compatibilidade -->
            <div id="tab-compatibility" class="tab-content">
                <div class="panel-header">
                    <h2 class="panel-title">Análise de Compatibilidade VisuAlG</h2>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span>Progresso Geral</span>
                        <span>38 de 39 recursos</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 97%;"></div>
                    </div>
                </div>

                <div class="compatibility-grid">
                    <!-- Estrutura Básica -->
                    <div class="card">
                        <h3 style="color: var(--editor-success); margin-top: 0;">✓ Estrutura Básica (100%)</h3>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>algoritmo "nome"...fimalgoritmo</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Seção var para declarações</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Comentários // e {...}</span>
                        </div>
                    </div>

                    <!-- Funções Matemáticas -->
                    <div class="card">
                        <h3 style="color: var(--editor-success); margin-top: 0;">✓ Funções Matemáticas (100%)</h3>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>ArcCos, ArcSen, ArcTan, CoTan</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>GraupRad, RadpGrau, LogN</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Rand, RandI</span>
                        </div>
                    </div>

                    <!-- Funções de String -->
                    <div class="card">
                        <h3 style="color: var(--editor-success); margin-top: 0;">✓ Funções de String (100%)</h3>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Asc, Carac, CaracpNum</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Copia, NumpCarac, Pos</span>
                        </div>
                    </div>

                    <!-- Operadores -->
                    <div class="card">
                        <h3 style="color: var(--editor-success); margin-top: 0;">✓ Operadores (100%)</h3>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Operador \ (divisão inteira)</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Operador ^ (potenciação)</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Operador xou (XOR lógico)</span>
                        </div>
                    </div>

                    <!-- Comandos Específicos -->
                    <div class="card">
                        <h3 style="color: var(--editor-warning); margin-top: 0;">⚠ Comandos Específicos (95%)</h3>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>aleatorio, timer, pausa</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>debug, eco, cronometro</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="x-circle" class="feature-missing"></i>
                            <span>arquivo "nome" (stub - parcial)</span>
                        </div>
                    </div>

                    <!-- Recursos Avançados -->
                    <div class="card">
                        <h3 style="color: var(--editor-success); margin-top: 0;">✓ Recursos Avançados (100%)</h3>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Vetores multidimensionais</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Recursão em funções</span>
                        </div>
                        <div class="feature-item">
                            <i data-lucide="check-circle" class="feature-implemented"></i>
                            <span>Passagem por referência</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- A entrada inline será exibida dentro do container de saída quando necessário -->
    </div>

    <script>
        // Definição da Linguagem Portugol e implementação de Parser
        class PortugolParser {
            constructor() {
                this.lines = [];
                this.currentLine = 0;
                this.errors = [];
                this.warnings = [];
            }

            parse(code) {
                this.lines = code.split(/\r?\n/).map(line => this.stripComments(line).trim());
                this.currentLine = 0;
                this.errors = [];
                this.warnings = [];

                try {
                    const ast = this.parseProgram();
                    return {
                        success: this.errors.length === 0,
                        ast,
                        errors: this.errors,
                        warnings: this.warnings
                    };
                } catch (error) {
                    this.errors.push(`Erro de parsing: ${error.message}`);
                    return {
                        success: false,
                        errors: this.errors,
                        warnings: this.warnings
                    };
                }
            }

            stripComments(line) {
                let result = line.replace(/\/\/.*$/, '');
                result = result.replace(/\{.*?\}/g, '');
                return result;
            }

            parseProgram() {
                const program = {
                    type: 'program',
                    name: '',
                    variables: [],
                    functions: [],
                    procedures: [],
                    body: []
                };

                const firstLine = this.getCurrentLine();
                if (!firstLine) {
                    this.errors.push('Programa vazio');
                    return program;
                }

                const algorithmMatch = firstLine.match(/^algoritmo\s+"([^"]+)"/i);
                if (!algorithmMatch) {
                    this.errors.push('Programa deve começar com: algoritmo "nome"');
                    return program;
                }

                program.name = algorithmMatch[1];
                this.nextLine();

                if (this.getCurrentLine()?.toLowerCase().trim() === 'var') {
                    this.nextLine();
                    program.variables = this.parseVariableSection();
                }

                while (this.hasMoreLines()) {
                    const line = this.getCurrentLine()?.toLowerCase().trim();
                    if (!line) {
                        this.nextLine();
                        continue;
                    }

                    if (line.startsWith('funcao ')) {
                        program.functions.push(this.parseFunction());
                    } else if (line.startsWith('procedimento ')) {
                        program.procedures.push(this.parseProcedure());
                    } else if (line === 'inicio') {
                        this.nextLine();
                        program.body = this.parseBody('fimalgoritmo');
                        break;
                    } else {
                        this.nextLine();
                    }
                }

                if (program.body.length === 0) {
                    this.errors.push('Programa deve ter seção inicio...fimalgoritmo');
                }

                return program;
            }

            parseVariableSection() {
                const variables = [];
                while (this.hasMoreLines()) {
                    const line = this.getCurrentLine();
                    if (!line || line.toLowerCase().trim() === 'inicio' || 
                        line.toLowerCase().trim().startsWith('funcao ') ||
                        line.toLowerCase().trim().startsWith('procedimento ')) {
                        break;
                    }

                    const varMatch = line.match(/^([^:]+):\s*(.+)$/);
                    if (varMatch) {
                        const names = varMatch[1].split(',').map(n => n.trim());
                        const typeDecl = varMatch[2].trim();
                        
                        for (const name of names) {
                            const variable = this.parseVariableDeclaration(name, typeDecl);
                            if (variable) {
                                variables.push({ variable });
                            }
                        }
                    }
                    this.nextLine();
                }
                return variables;
            }

            parseVariableDeclaration(name, typeDecl) {
                const vectorMatch = typeDecl.match(/^vetor\[(.+?)\]\s+de\s+(.+)$/i);
                if (vectorMatch) {
                    const dimensionsStr = vectorMatch[1];
                    const baseType = vectorMatch[2].toLowerCase();
                    const dimensions = this.parseDimensions(dimensionsStr);
                    
                    return {
                        name: name,
                        type: baseType,
                        isArray: true,
                        arrayDimensions: dimensions
                    };
                } else {
                    return {
                        name: name,
                        type: typeDecl.toLowerCase(),
                        isArray: false
                    };
                }
            }

            parseDimensions(dimensionsStr) {
                const dimensions = [];
                const parts = dimensionsStr.split(',');
                
                for (const part of parts) {
                    const rangeMatch = part.trim().match(/^(-?\d+)\.\.(-?\d+)$/);
                    if (rangeMatch) {
                        dimensions.push({
                            start: parseInt(rangeMatch[1]),
                            end: parseInt(rangeMatch[2])
                        });
                    }
                }
                return dimensions;
            }

            parseFunction() {
                // Análise de função aprimorada: suporta múltiplos estilos de cabeçalho, variáveis locais e 'inicio' opcional
                const header = this.getCurrentLine();
                if (!header) {
                    this.errors.push('Formato de função inválido');
                    return null;
                }

                // Estilos suportados:
                // 1) funcao nome(params): tipo
                // 2) funcao tipo nome(params)
                // 3) funcao nome: tipo
                let name = '';
                let returnType = 'inteiro';
                let paramsStr = '';

                let m = header.match(/^funcao\s+([^(:\s]+)\s*\(([^)]*)\)\s*:\s*(\w+)\s*$/i);
                if (m) {
                    name = m[1].trim();
                    paramsStr = (m[2] || '').trim();
                    returnType = m[3].trim();
                } else {
                    m = header.match(/^funcao\s+(\w+)\s+([^\(\s]+)\s*\(([^)]*)\)\s*$/i);
                    if (m) {
                        returnType = m[1].trim();
                        name = m[2].trim();
                        paramsStr = (m[3] || '').trim();
                    } else {
                        m = header.match(/^funcao\s+([^:]+):\s*(.+)$/i);
                        if (m) {
                            name = m[1].trim();
                            returnType = m[2].trim();
                        } else {
                            this.errors.push('Formato de função inválido');
                            return null;
                        }
                    }
                }

                const parameters = [];
                if (paramsStr) {
                    for (const rawParam of paramsStr.split(',')) {
                        const p = rawParam.trim();
                        if (!p) continue;
                        let byRef = false;
                        let namePart = p;
                        // Remover parte do tipo antes de ':' se existir
                        if (namePart.includes(':')) {
                            namePart = namePart.split(':')[0].trim();
                        }
                        // Detectar 'var' no início (passagem por referência do VisualG)
                        if (/^var\b/i.test(namePart)) {
                            byRef = true;
                            namePart = namePart.replace(/^var\b\s*/i, '').trim();
                        }
                        // Se ainda contiver espaços como "tipo nome", usar o último token como nome
                        if (namePart.includes(' ')) {
                            const tokens = namePart.split(/\s+/);
                            namePart = tokens[tokens.length - 1].trim();
                        }
                        parameters.push({ name: namePart, byRef });
                    }
                }

                const func = {
                    name: name,
                    returnType: returnType,
                    parameters: parameters,
                    locals: [],
                    body: []
                };

                // Avançar após o cabeçalho
                this.nextLine();

                // Seção opcional de variáveis locais dentro da função
                if (this.getCurrentLine()?.toLowerCase().trim() === 'var') {
                    this.nextLine();
                    func.locals = this.parseVariableSection();
                }

                // 'inicio' opcional dentro da função
                if (this.getCurrentLine()?.toLowerCase().trim() === 'inicio') {
                    this.nextLine();
                }

                func.body = this.parseBody('fimfuncao');
                return func;
            }

            parseProcedure() {
                const header = this.getCurrentLine();
                if (!header) {
                    this.errors.push('Formato de procedimento inválido');
                    return null;
                }

                // Suporta: "procedimento nome(params)" ou "procedimento nome"
                const m = header.match(/^procedimento\s+([a-zA-Z_]\w*)\s*(?:\(([^)]*)\))?\s*$/i);
                if (!m) {
                    this.errors.push('Formato de procedimento inválido');
                    return null;
                }

                const name = m[1].trim();
                const paramsStr = (m[2] || '').trim();

                const parameters = [];
                if (paramsStr) {
                    for (const rawParam of paramsStr.split(',')) {
                        const p = rawParam.trim();
                        if (!p) continue;
                        let byRef = false;
                        let namePart = p;
                        // Remover parte do tipo antes de ':' se existir
                        if (namePart.includes(':')) {
                            namePart = namePart.split(':')[0].trim();
                        }
                        // Detectar 'var' no início (passagem por referência do VisualG)
                        if (/^var\b/i.test(namePart)) {
                            byRef = true;
                            namePart = namePart.replace(/^var\b\s*/i, '').trim();
                        }
                        // Se ainda contiver espaços como "tipo nome", usar o último token como nome
                        if (namePart.includes(' ')) {
                            const tokens = namePart.split(/\s+/);
                            namePart = tokens[tokens.length - 1].trim();
                        }
                        parameters.push({ name: namePart, byRef });
                    }
                }

                const proc = {
                    name: name,
                    parameters: parameters,
                    locals: [],
                    body: []
                };

                // Avança após o cabeçalho
                this.nextLine();

                // Seção opcional de variáveis locais
                if (this.getCurrentLine()?.toLowerCase().trim() === 'var') {
                    this.nextLine();
                    proc.locals = this.parseVariableSection();
                }

                // 'inicio' opcional dentro do procedimento
                if (this.getCurrentLine()?.toLowerCase().trim() === 'inicio') {
                    this.nextLine();
                }

                proc.body = this.parseBody('fimprocedimento');
                return proc;
            }

            parseBody(...endKeywords) {
                const statements = [];
                const ends = (endKeywords && endKeywords.length > 0)
                    ? endKeywords.map(k => String(k).toLowerCase())
                    : [];
                while (this.hasMoreLines()) {
                    const current = this.getCurrentLine();
                    const line = current?.toLowerCase().trim();
                    if (!line) {
                        this.nextLine();
                        continue;
                    }

                    if (ends.length > 0 && ends.includes(line)) {
                        // Se múltiplos possíveis tokens de término forem fornecidos (por exemplo, 'senao' ou 'fimse'),
                        // NÃO consuma o token de término aqui. O chamador irá tratá-lo (necessário para lidar com o 'senao').
                        // Se apenas um token de término for fornecido, consuma-o para preservar o comportamento anterior.
                        if (ends.length === 1) {
                            this.nextLine();
                        }
                        break;
                    }

                    const stmt = this.parseStatement();
                    if (stmt) {
                        statements.push(stmt);
                    }
                }
                return statements;
            }

            parseStatement() {
                const line = this.getCurrentLine();
                if (!line) {
                    this.nextLine();
                    return null;
                }

                const trimmed = line.trim().toLowerCase();

                if (trimmed.startsWith('escreva') || trimmed.startsWith('escreval')) {
                    return this.parseWriteStatement(line);
                } else if (trimmed.startsWith('leia')) {
                    return this.parseReadStatement(line);
                } else if (trimmed.includes('<-')) {
                    return this.parseAssignmentStatement(line);
                } else if (trimmed.startsWith('se ')) {
                    return this.parseIfStatement();
                } else if (trimmed.startsWith('para ')) {
                    return this.parseForStatement();
                } else if (trimmed.startsWith('enquanto ')) {
                    return this.parseWhileStatement();
                } else if (trimmed.startsWith('repita')) {
                    return this.parseRepeatStatement();
                } else if (trimmed.startsWith('retorna') || trimmed.startsWith('retorne')) {
                    // Instrução de retorno dentro de funções
                    const m = line.match(/^retorn[ae]\s*(.*)$/i);
                    const expr = (m && m[1] ? m[1].trim() : '0');
                    this.nextLine();
                    return { type: 'return', expression: expr };
                } else if (trimmed === 'interrompa') {
                    this.nextLine();
                    return { type: 'break' };
                } else if (trimmed.startsWith('limpatela')) {
                    this.nextLine();
                    return { type: 'command', name: 'limpatela' };
                } else if (trimmed.startsWith('aleatorio')) {
                    this.nextLine();
                    return { type: 'command', name: 'aleatorio' };
                } else if (trimmed.startsWith('timer')) {
                    this.nextLine();
                    return { type: 'command', name: 'timer' };
                } else if (trimmed.startsWith('pausa')) {
                    this.nextLine();
                    return { type: 'command', name: 'pausa' };
                } else if (trimmed.startsWith('debug')) {
                    this.nextLine();
                    return { type: 'command', name: 'debug' };
                } else if (trimmed.startsWith('eco')) {
                    this.nextLine();
                    return { type: 'command', name: 'eco' };
                } else if (trimmed.startsWith('cronometro')) {
                    this.nextLine();
                    return { type: 'command', name: 'cronometro' };
                } else if (trimmed.startsWith('arquivo')) {
                    const m = line.match(/^arquivo\s*(?:\(\s*"([^"]*)"\s*\)|"([^"]*)")/i);
                    const nome = m ? (m[1] || m[2] || '').trim() : '';
                    this.nextLine();
                    return { type: 'command', name: 'arquivo', args: [nome] };
                } else {
                    // Tentar identificar chamada de função/procedimento como instrução
                    const callMatch = line.match(/^(\w+)\s*\((.*)\)\s*$/);
                    this.nextLine();
                    if (callMatch) {
                        const callName = callMatch[1];
                        const argsStr = callMatch[2] || '';
                        const args = argsStr ? this.parseExpressionList(argsStr) : [];
                        return { type: 'call', name: callName, args };
                    }
                    // Caso contrário, tratar como expressão genérica (sem efeito)
                    return { type: 'expression', value: line };
                }
            }

            parseWriteStatement(line) {
                this.nextLine();
                const isNewline = line.toLowerCase().trim().startsWith('escreval');
                const contentMatch = line.match(/escreval?\((.+)\)/i);
                
                let expressions = [];
                if (contentMatch) {
                    expressions = this.parseExpressionList(contentMatch[1]);
                }

                return {
                    type: 'write',
                    expressions,
                    newline: isNewline
                };
            }

            parseReadStatement(line) {
                this.nextLine();
                // Aceita tanto leia(x, y) quanto leia x, y
                let variables = [];
                let inside = '';
                const parenMatch = line.match(/leia\s*\(\s*(.*?)\s*\)/i);
                if (parenMatch) {
                    inside = parenMatch[1] || '';
                } else {
                    const noParenMatch = line.match(/leia\s+(.+)/i);
                    if (noParenMatch) {
                        inside = (noParenMatch[1] || '').trim();
                    }
                }

                if (inside.length > 0) {
                    // Suporta separação por vírgula; se não houver vírgula, aceita espaço único
                    if (inside.includes(',')) {
                        variables = inside.split(',').map(v => v.trim()).filter(v => v.length > 0);
                    } else {
                        variables = inside.split(/\s+/).map(v => v.trim()).filter(v => v.length > 0);
                    }
                }

                return {
                    type: 'read',
                    variables
                };
            }

            parseAssignmentStatement(line) {
                this.nextLine();
                const parts = line.split('<-');
                if (parts.length !== 2) {
                    this.errors.push('Atribuição inválida');
                    return null;
                }

                return {
                    type: 'assignment',
                    target: parts[0].trim(),
                    expression: parts[1].trim()
                };
            }

            parseIfStatement() {
                const startLine = this.currentLine;
                const line = this.getCurrentLine();
                const conditionMatch = line.match(/^se\s+(.+?)\s+entao$/i);
                
                if (!conditionMatch) {
                    this.errors.push('Formato de SE inválido');
                    this.nextLine();
                    return null;
                }

                this.nextLine();
                const thenBlock = this.parseBody('senao', 'fimse');
                
                let elseBlock = [];
                const currentLine = this.getCurrentLine()?.toLowerCase().trim();
                if (currentLine === 'senao') {
                    this.nextLine();
                    elseBlock = this.parseBody('fimse');
                } else if (currentLine === 'fimse') {
                    // Consumir o token de fechamento aqui se não houver 'senao'
                    this.nextLine();
                }

                return {
                    type: 'if',
                    condition: conditionMatch[1],
                    thenBlock,
                    elseBlock
                };
            }

            parseForStatement() {
                const line = this.getCurrentLine();
                const forMatch = line.match(/^para\s+(\w+)\s+de\s+(.+?)\s+ate\s+(.+?)\s+faca$/i);
                
                if (!forMatch) {
                    this.errors.push('Formato de PARA inválido');
                    this.nextLine();
                    return null;
                }

                this.nextLine();
                const body = this.parseBody('fimpara');

                return {
                    type: 'for',
                    variable: forMatch[1],
                    start: forMatch[2],
                    end: forMatch[3],
                    body
                };
            }

            parseWhileStatement() {
                const line = this.getCurrentLine();
                const whileMatch = line.match(/^enquanto\s+(.+?)\s+faca$/i);
                
                if (!whileMatch) {
                    this.errors.push('Formato de ENQUANTO inválido');
                    this.nextLine();
                    return null;
                }

                this.nextLine();
                const body = this.parseBody('fimenquanto');

                return {
                    type: 'while',
                    condition: whileMatch[1],
                    body
                };
            }

            parseRepeatStatement() {
                this.nextLine();
                const body = this.parseBody('ate');
                
                const untilLine = this.getCurrentLine();
                const untilMatch = untilLine?.match(/^ate\s+(.+)$/i);
                
                if (!untilMatch) {
                    this.errors.push('REPITA sem ATE');
                    return null;
                }

                this.nextLine();

                return {
                    type: 'repeat',
                    body,
                    condition: untilMatch[1]
                };
            }

            parseExpressionList(str) {
                const expressions = [];
                let current = '';
                let parentheses = 0;
                let brackets = 0;
                let inString = false;
                
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    
                    if (char === '"' && str[i-1] !== '\\') {
                        inString = !inString;
                    }
                    
                    if (!inString) {
                        if (char === '(') parentheses++;
                        if (char === ')') parentheses--;
                        if (char === '[') brackets++;
                        if (char === ']') brackets--;
                        
                        if (char === ',' && parentheses === 0 && brackets === 0) {
                            expressions.push(current.trim());
                            current = '';
                            continue;
                        }
                    }
                    
                    current += char;
                }
                
                if (current.trim()) {
                    expressions.push(current.trim());
                }
                
                return expressions;
            }

            getCurrentLine() {
                return this.currentLine < this.lines.length ? this.lines[this.currentLine] : null;
            }

            nextLine() {
                this.currentLine++;
            }

            hasMoreLines() {
                return this.currentLine < this.lines.length;
            }
        }

        // Implementação do Interpretador de Portugol
        class PortugolInterpreter {
            constructor() {
                this.env = this.createEnvironment();
                this.functions = new PortugolFunctions();
            }

            execute(ast, options = {}) {
                try {
                    this.env = this.createEnvironment();
                    if (options && Array.isArray(options.inputQueue)) {
                        this.env.inputQueue = [...options.inputQueue];
                    }
                    if (options && options.interactive && options.requestNextInput) {
                        this.env.requestNextInput = options.requestNextInput;
                    }
                    // Anexar sinalização de debug a partir das opções
                    if (options && typeof options.debugMode === 'boolean') {
                        this.env.debugMode = options.debugMode;
                    }
                    this.env.programStartTime = Date.now();
                    this.executeProgram(ast);
                    
                    return {
                        success: true,
                        output: [...this.env.output],
                        errors: [],
                        finalState: this.env
                    };
                } catch (error) {
                    if (options && options.interactive && error && error.__portugol_need_input__) {
                        return {
                            success: false,
                            needInput: true,
                            variables: error.variables || [],
                            prompt: error.prompt || '',
                            output: [...this.env.output],
                            finalState: this.env
                        };
                    } else {
                        return {
                            success: false,
                            output: [...this.env.output],
                            errors: [error.message],
                            finalState: this.env
                        };
                    }
                }
            }

            createEnvironment() {
                return {
                    variables: new Map(),
                    functions: new Map(),
                    procedures: new Map(),
                    output: [],
                    randomEnabled: false,
                    debugMode: false,
                    echoEnabled: true,
                    inputQueue: [],
                    programStartTime: Date.now(),
                    chronoStart: null,
                    chronoRunning: false,
                    fileName: ''
                };
            }

            executeProgram(ast) {
                if (ast.type !== 'program') {
                    throw new Error('AST inválida: deve ser um programa');
                }

                // Declarar variáveis globais
                if (ast.variables) {
                    for (const varDecl of ast.variables) {
                        this.declareVariable(varDecl);
                    }
                }

                // Registrar funções
                if (ast.functions) {
                    for (const func of ast.functions) {
                        this.env.functions.set(func.name.toLowerCase(), func);
                    }
                }

                // Registrar procedimentos
                if (ast.procedures) {
                    for (const proc of ast.procedures) {
                        this.env.procedures.set(proc.name.toLowerCase(), proc);
                    }
                }

                // Executar corpo principal
                if (ast.body) {
                    this.executeStatements(ast.body);
                }
            }

            declareVariable(varDecl) {
                const { variable } = varDecl;
                if (!variable) return;

                if (variable.isArray) {
                    if (variable.arrayDimensions && variable.arrayDimensions.length > 0) {
                        const array = this.createMultiDimensionalArray(variable.arrayDimensions, variable.type);
                        this.env.variables.set(variable.name, array);
                    }
                } else {
                    const defaultValue = this.getDefaultValue(variable.type);
                    this.env.variables.set(variable.name, defaultValue);
                }
            }

            createMultiDimensionalArray(dimensions, type) {
                if (dimensions.length === 1) {
                    const dim = dimensions[0];
                    const size = dim.end - dim.start + 1;
                    const array = new Array(size);
                    const defaultValue = this.getDefaultValue(type);
                    for (let i = 0; i < size; i++) {
                        array[i] = defaultValue;
                    }
                    return { data: array, startIndex: dim.start };
                } else {
                    const firstDim = dimensions[0];
                    const size = firstDim.end - firstDim.start + 1;
                    const array = new Array(size);
                    const remainingDims = dimensions.slice(1);
                    
                    for (let i = 0; i < size; i++) {
                        array[i] = this.createMultiDimensionalArray(remainingDims, type);
                    }
                    return { data: array, startIndex: firstDim.start };
                }
            }

            getDefaultValue(type) {
                switch (type.toLowerCase()) {
                    case 'inteiro': return 0;
                    case 'real': return 0.0;
                    case 'caractere': return '';
                    case 'logico': return false;
                    default: return null;
                }
            }

            // Resolver nome de variável para a chave declarada sem diferenciar maiúsculas de minúsculas
            // Retorna a chave existente se encontrada; caso contrário, retorna o nome original
            resolveVariableName(name) {
                const requested = String(name || '').toLowerCase();
                for (const key of this.env.variables.keys()) {
                    if (String(key).toLowerCase() === requested) {
                        return key;
                    }
                }
                return name;
            }

            executeStatements(statements) {
                for (const stmt of statements) {
                    this.executeStatement(stmt);
                }
            }

            executeStatement(stmt) {
                if (!stmt) return;

                switch (stmt.type) {
                    case 'write':
                        this.executeWrite(stmt);
                        break;
                    case 'read':
                        this.executeRead(stmt);
                        break;
                    case 'assignment':
                        this.executeAssignment(stmt);
                        break;
                    case 'call':
                        this.executeCall(stmt);
                        break;
                    case 'if':
                        this.executeIf(stmt);
                        break;
                    case 'for':
                        this.executeFor(stmt);
                        break;
                    case 'while':
                        this.executeWhile(stmt);
                        break;
                    case 'repeat':
                        this.executeRepeat(stmt);
                        break;
                    case 'return':
                        // Sinalizar retorno de função com valor
                        const retVal = this.evaluateExpression(stmt.expression);
                        throw { __portugol_return__: true, value: retVal };
                    
                    case 'command':
                        this.executeCommand(stmt);
                        break;
                    case 'break':
                        throw new Error('BREAK_LOOP');
                    default:
                        // Executar outras instruções
                        break;
                }
            }

            executeWrite(stmt) {
                const values = [];
                for (const expr of stmt.expressions) {
                    const value = this.evaluateExpression(expr);
                    values.push(String(value));
                }
                
                const output = values.join('');
                if (stmt.newline) {
                    this.env.output.push(output);
                } else {
                    // Anexar à linha atual quando não for solicitada quebra de linha
                    if (this.env.output.length === 0) {
                        this.env.output.push(output);
                    } else {
                        const lastIndex = this.env.output.length - 1;
                        this.env.output[lastIndex] = String(this.env.output[lastIndex]) + output;
                    }
                }
            }

            executeRead(stmt) {
                // Ler valores um a um; se faltar, solicitar interativamente usando o último prompt e o nome da variável
                for (const target of stmt.variables) {
                    let hasValue = this.env.inputQueue && this.env.inputQueue.length > 0;
                    if (!hasValue && typeof this.env.requestNextInput === 'function') {
                        const lastOut = this.env.output.length > 0 ? this.env.output[this.env.output.length - 1] : '';
                        // Garantir que cada 'leia' fique visualmente separado em sua própria linha finalizando a linha de saída atual
                        this.env.output.push('');
                        const provided = this.env.requestNextInput({ variable: target, prompt: lastOut });
                        if (provided !== undefined && provided !== null) {
                            this.env.inputQueue = this.env.inputQueue || [];
                            this.env.inputQueue.push(String(provided));
                            hasValue = true;
                        }
                    }

                    let rawInput = hasValue ? String(this.env.inputQueue.shift()) : '';
                    if (!hasValue) {
                        // Como fallback, ainda solicitar via caminho de erro
                        const lastOut = this.env.output.length > 0 ? this.env.output[this.env.output.length - 1] : '';
                        // Garantir linha de separação antes de solicitar entrada
                        this.env.output.push('');
                        throw { __portugol_need_input__: true, variables: [target], prompt: lastOut };
                    }

                    // Tratar leitura de elemento de vetor: nome[idx]
                    const arrayMatch = target.match(/^(\w+)\[(.+)\]$/);
                    if (arrayMatch) {
                        const arrayName = this.resolveVariableName(arrayMatch[1]);
                        const inside = arrayMatch[2];
                        const indexExprs = this.splitTopLevel(inside);
                        const indices = indexExprs.map(expr => this.evaluateExpression(expr));
                        const arrayObj = this.getVariableValue(arrayName);
                        if (arrayObj && arrayObj.data) {
                            // Determinar o tipo na folha para fazer o parsing
                            const currentVal = this.getArrayElement(arrayObj, indices);
                            let parsed;
                            if (typeof currentVal === 'number') {
                                const s = rawInput.trim();
                                const unquoted = s.replace(/^"(.*)"$/, '$1').replace(/^'(.*)'$/, '$1');
                                const digitsOnly = unquoted.replace(/,/g, '.').replace(/[^0-9.+\-]/g, '');
                                const n = parseFloat(digitsOnly);
                                if (isNaN(n)) {
                                    const lastOut = this.env.output.length > 0 ? this.env.output[this.env.output.length - 1] : '';
                                    if (typeof this.env.requestNextInput === 'function') {
                                        this.env.requestNextInput({ variable: target, prompt: lastOut });
                                    }
                                    throw { __portugol_need_input__: true, variables: [target], prompt: lastOut };
                                }
                                parsed = n;
                            } else if (typeof currentVal === 'boolean') {
                                const s = rawInput.trim().toLowerCase();
                                if (s === 'verdadeiro' || s === 'true' || s === '1') parsed = true;
                                else if (s === 'falso' || s === 'false' || s === '0') parsed = false;
                                else {
                                    const lastOut = this.env.output.length > 0 ? this.env.output[this.env.output.length - 1] : '';
                                    if (typeof this.env.requestNextInput === 'function') {
                                        this.env.requestNextInput({ variable: target, prompt: lastOut });
                                    }
                                    throw { __portugol_need_input__: true, variables: [target], prompt: lastOut };
                                }
                            } else {
                                const s = rawInput.trim();
                                parsed = (s.startsWith('"') && s.endsWith('"')) ? s.slice(1, -1) : s;
                            }
                            this.setArrayElement(arrayObj, indices, parsed);
                            // Repetir a entrada bruta para que o valor digitado permaneça visível na tela (se habilitado)
                            if (this.env.echoEnabled && typeof rawInput === 'string') {
                                const lastIdx = this.env.output.length - 1;
                                if (lastIdx >= 0 && this.env.output[lastIdx] === '') {
                                    this.env.output[lastIdx] = String(rawInput);
                                } else {
                                    this.env.output.push(String(rawInput));
                                }
                            }
                        }
                        continue;
                    }

                    const varName = this.resolveVariableName(target);
                    const current = this.getVariableValue(varName);
                    let parsedValue;
                    if (typeof current === 'number') {
                        const s = rawInput.trim();
                        const unquoted = s.replace(/^"(.*)"$/, '$1').replace(/^'(.*)'$/, '$1');
                        const digitsOnly = unquoted.replace(/,/g, '.').replace(/[^0-9.+\-]/g, '');
                        const n = parseFloat(digitsOnly);
                        if (isNaN(n)) {
                            const lastOut = this.env.output.length > 0 ? this.env.output[this.env.output.length - 1] : '';
                            if (typeof this.env.requestNextInput === 'function') {
                                this.env.requestNextInput({ variable: target, prompt: lastOut });
                            }
                            throw { __portugol_need_input__: true, variables: [target], prompt: lastOut };
                        }
                        parsedValue = n;
                    } else if (typeof current === 'boolean') {
                        const s = rawInput.trim().toLowerCase();
                        if (s === 'verdadeiro' || s === 'true' || s === '1') parsedValue = true;
                        else if (s === 'falso' || s === 'false' || s === '0') parsedValue = false;
                        else {
                            const lastOut = this.env.output.length > 0 ? this.env.output[this.env.output.length - 1] : '';
                            if (typeof this.env.requestNextInput === 'function') {
                                this.env.requestNextInput({ variable: target, prompt: lastOut });
                            }
                            throw { __portugol_need_input__: true, variables: [target], prompt: lastOut };
                        }
                    } else {
                        const s = rawInput.trim();
                        parsedValue = (s.startsWith('"') && s.endsWith('"')) ? s.slice(1, -1) : s;
                    }
                    this.env.variables.set(varName, parsedValue);
                    // Repetir a entrada bruta para que o valor digitado permaneça visível na tela (se habilitado)
                    if (this.env.echoEnabled && typeof rawInput === 'string') {
                        const lastIdx = this.env.output.length - 1;
                        if (lastIdx >= 0 && this.env.output[lastIdx] === '') {
                            this.env.output[lastIdx] = String(rawInput);
                        } else {
                            this.env.output.push(String(rawInput));
                        }
                    }
                }
            }

            executeAssignment(stmt) {
                const value = this.evaluateExpression(stmt.expression);
                
                // Tratar atribuição em vetor como valores[1] <- 10.5
                if (stmt.target.includes('[')) {
                    const arrayMatch = stmt.target.match(/^(\w+)\[(.+)\]$/);
                    if (arrayMatch) {
                        const arrayName = this.resolveVariableName(arrayMatch[1]);
                        const inside = arrayMatch[2];
                        const indexExprs = this.splitTopLevel(inside);
                        const indices = indexExprs.map(expr => this.evaluateExpression(expr));
                        const arrayObj = this.getVariableValue(arrayName);
                        if (arrayObj && arrayObj.data) {
                            this.setArrayElement(arrayObj, indices, value);
                        }
                    }
                } else {
                    const varKey = this.resolveVariableName(stmt.target);
                    this.setVariableValue(varKey, value);
                }
            }

            executeIf(stmt) {
                const condition = this.evaluateExpression(stmt.condition);
                if (this.isTruthy(condition)) {
                    this.executeStatements(stmt.thenBlock);
                } else if (stmt.elseBlock.length > 0) {
                    this.executeStatements(stmt.elseBlock);
                }
            }

            executeFor(stmt) {
                const start = this.evaluateExpression(stmt.start);
                const end = this.evaluateExpression(stmt.end);
                
                try {
                    for (let i = start; i <= end; i++) {
                        this.env.variables.set(stmt.variable, i);
                        this.executeStatements(stmt.body);
                    }
                } catch (error) {
                    if (error.message === 'BREAK_LOOP') {
                        // Interromper o laço
                    } else {
                        throw error;
                    }
                }
            }

            executeWhile(stmt) {
                try {
                    while (this.isTruthy(this.evaluateExpression(stmt.condition))) {
                        this.executeStatements(stmt.body);
                    }
                } catch (error) {
                    if (error.message === 'BREAK_LOOP') {
                        // Interromper o laço
                    } else {
                        throw error;
                    }
                }
            }

            executeRepeat(stmt) {
                try {
                    do {
                        this.executeStatements(stmt.body);
                    } while (!this.isTruthy(this.evaluateExpression(stmt.condition)));
                } catch (error) {
                    if (error.message === 'BREAK_LOOP') {
                        // Interromper o laço
                    } else {
                        throw error;
                    }
                }
            }

            executeCommand(stmt) {
                switch (stmt.name) {
                    case 'limpatela':
                        this.env.output = [];
                        this.env.output.push('Tela limpa');
                        break;
                    case 'aleatorio':
                        this.env.randomEnabled = !this.env.randomEnabled;
                        this.env.output.push(`Geração aleatória ${this.env.randomEnabled ? 'ativada' : 'desativada'}`);
                        break;
                    case 'timer':
                        if (!this.env.programStartTime) this.env.programStartTime = Date.now();
                        {
                            const elapsed = Date.now() - this.env.programStartTime;
                            this.env.output.push(`Tempo decorrido: ${elapsed} ms`);
                        }
                        break;
                    case 'pausa':
                        // Simula pausa de execução (não bloqueante no navegador)
                        this.env.output.push('Pausa solicitada (ignorada no ambiente web)');
                        break;
                    case 'debug':
                        this.env.debugMode = !this.env.debugMode;
                        this.env.output.push(`Debug ${this.env.debugMode ? 'ativado' : 'desativado'}`);
                        break;
                    case 'eco':
                        this.env.echoEnabled = !this.env.echoEnabled;
                        this.env.output.push(`Eco de entrada ${this.env.echoEnabled ? 'ativado' : 'desativado'}`);
                        break;
                    case 'cronometro':
                        if (!this.env.chronoRunning) {
                            this.env.chronoStart = Date.now();
                            this.env.chronoRunning = true;
                            this.env.output.push('Cronômetro iniciado');
                        } else {
                            const elapsed = Date.now() - (this.env.chronoStart || Date.now());
                            this.env.chronoRunning = false;
                            this.env.chronoStart = null;
                            this.env.output.push(`Cronômetro: ${elapsed} ms`);
                        }
                        break;
                    case 'arquivo':
                        {
                            const nome = (stmt.args && stmt.args[0]) ? String(stmt.args[0]) : '';
                            this.env.fileName = nome;
                            this.env.output.push(`Arquivo configurado: ${nome || '(vazio)'} (somente stub)`);
                        }
                        break;
                }
            }

            executeCall(stmt) {
                const funcName = String(stmt.name || '').toLowerCase();
                let evaluatedArgs;
                try {
                    evaluatedArgs = (stmt.args || []).map(arg => this.evaluateExpression(arg));
                } catch (e) {
                    if (e && e.__portugol_need_input__) {
                        // Propagar a solicitação de entrada para que o loop externo possa tratá-la
                        throw e;
                    }
                    throw e;
                }

                // Chamar procedimento definido pelo usuário
                if (this.env.procedures.has(funcName)) {
                    const proc = this.env.procedures.get(funcName);
                    const previousVariables = this.env.variables;
                    const previousRefs = this.env.refs || new Map();
                    this.env.variables = new Map(previousVariables);
                    this.env.refs = new Map();
                    try {
                        // Vincular parâmetros por nome
                        for (let i = 0; i < (proc.parameters || []).length; i++) {
                            const spec = proc.parameters[i] || {};
                            const paramName = spec.name || spec || `param${i+1}`;
                            const byRef = !!spec.byRef;
                            const argValue = i < evaluatedArgs.length ? evaluatedArgs[i] : 0;
                            this.env.variables.set(paramName, argValue);
                            if (byRef) {
                                const rawArg = (stmt.args && stmt.args[i]) ? String(stmt.args[i]).trim() : '';
                                if (/^[a-zA-Z_]\w*$/.test(rawArg)) {
                                    const targetKey = this.resolveVariableName(rawArg);
                                    this.env.refs.set(paramName, { map: previousVariables, key: targetKey });
                                    // Inicializar local com o valor atual referenciado
                                    this.env.variables.set(paramName, previousVariables.has(targetKey) ? previousVariables.get(targetKey) : 0);
                                }
                            }
                        }
                        // Declarar variáveis locais
                        if (proc.locals && proc.locals.length) {
                            for (const localDecl of proc.locals) {
                                this.declareVariable(localDecl);
                            }
                        }
                        // Executar corpo
                        this.executeStatements(proc.body || []);
                    } finally {
                        this.env.variables = previousVariables;
                        this.env.refs = previousRefs;
                    }
                    return;
                }

                // Chamar função definida pelo usuário descartando retorno
                if (this.env.functions.has(funcName)) {
                    // Avaliar via caminho de função para respeitar escopo/retorno
                    try {
                        void this.evaluateFunctionCall(`${stmt.name}(${(stmt.args||[]).join(', ')})`);
                    } catch (e) {
                        if (e && e.__portugol_need_input__) throw e;
                        throw e;
                    }
                    return;
                }

                // Chamar funções internas conhecidas (descarta retorno)
                try {
                    try {
                        void this.evaluateFunctionCall(`${stmt.name}(${(stmt.args||[]).join(', ')})`);
                    } catch (e) {
                        if (e && e.__portugol_need_input__) throw e;
                        throw e;
                    }
                } catch (e) {
                    throw new Error(`Função/procedimento '${stmt.name}' não foi definido`);
                }
            }

            evaluateExpression(expr) {
                if (typeof expr === 'number') return expr;
                if (typeof expr === 'boolean') return expr;
                
                const str = String(expr).trim();
                
                // Literal de string
                if (str.startsWith('"') && str.endsWith('"')) {
                    return str.slice(1, -1);
                }
                
                // Literal numérico (deve corresponder ao token inteiro)
                if (/^-?\d+(?:[.,]\d+)?$/.test(str)) {
                    return parseFloat(str.replace(',', '.'));
                }
                
                // Literal booleano
                if (str.toLowerCase() === 'verdadeiro' || str.toLowerCase() === 'true') return true;
                if (str.toLowerCase() === 'falso' || str.toLowerCase() === 'false') return false;
                
                // Acesso a vetor como valores[1]
                if (str.includes('[')) {
                    const arrayMatch = str.match(/^(\w+)\[(.+)\]$/);
                    if (arrayMatch) {
                        const rawName = arrayMatch[1];
                        const inside = arrayMatch[2];
                        const indexExprs = this.splitTopLevel(inside);
                        const indices = indexExprs.map(expr => this.evaluateExpression(expr));
                        
                        // Resolver nome de variável sem diferenciar maiúsculas/minúsculas
                        const arrayName = this.resolveVariableName(rawName);
                        const arrayObj = this.getVariableValue(arrayName);
                        if (arrayObj && arrayObj.data) {
                            return this.getArrayElement(arrayObj, indices);
                        }
                        return 0;
                    }
                }
                
                // Referência de variável (sem diferenciar maiúsculas de minúsculas)
                const resolvedName = this.resolveVariableName(str);
                if (this.env.variables.has(resolvedName)) {
                    return this.getVariableValue(resolvedName);
                }
                
                // Constantes embutidas (sem parênteses)
                if (str.toLowerCase() === 'pi') {
                    return Math.PI;
                }
                
                // Chamadas de função: apenas se começar com um identificador antes de '('
                if (/^[a-zA-Z_]\w*\s*\(/.test(str)) {
                    return this.evaluateFunctionCall(str);
                }
                
                // Operadores ou expressões lógicas/de comparação
                if (
                    /[\\^%]/.test(str) ||
                    /[+\-*/]/.test(str) ||
                    /[<>=!]/.test(str) ||
                    /\b(e|ou|nao|xou|mod|pi)\b/i.test(str)
                ) {
                    return this.evaluateArithmetic(str);
                }
                
                return 0; // Valor padrão
            }

            evaluateFunctionCall(expr) {
                const functionMatch = expr.match(/^(\w+)\((.*)?\)$/);
                if (!functionMatch) return 0;
                
                const funcName = functionMatch[1].toLowerCase();
                const argsStr = functionMatch[2] || '';
                
                const args = argsStr ? argsStr.split(',').map(arg => this.evaluateExpression(arg.trim())) : [];
                const rawArgs = argsStr ? this.splitTopLevel(argsStr) : [];
                
                // Funções definidas pelo usuário
                if (this.env.functions.has(funcName)) {
                    const func = this.env.functions.get(funcName);
                    // Criar um novo escopo local copiando superficialmente o mapa de variáveis
                    const previousVariables = this.env.variables;
                    const previousRefs = this.env.refs || new Map();
                    this.env.variables = new Map(previousVariables);
                    this.env.refs = new Map();
                    try {
                        // Vincular parâmetros por nome
                        for (let i = 0; i < func.parameters.length; i++) {
                            const spec = func.parameters[i] || {};
                            const paramName = spec.name || spec || `param${i+1}`;
                            const byRef = !!spec.byRef;
                            const argValue = i < args.length ? args[i] : 0;
                            this.env.variables.set(paramName, argValue);
                            if (byRef) {
                                const rawArg = rawArgs[i] ? String(rawArgs[i]).trim() : '';
                                if (/^[a-zA-Z_]\w*$/.test(rawArg)) {
                                    const targetKey = this.resolveVariableName(rawArg);
                                    this.env.refs.set(paramName, { map: previousVariables, key: targetKey });
                                    // Inicializar local com o valor atual referenciado
                                    this.env.variables.set(paramName, previousVariables.has(targetKey) ? previousVariables.get(targetKey) : 0);
                                }
                            }
                        }
                        // Declarar variáveis locais com valores padrão
                        if (func.locals && func.locals.length) {
                            for (const localDecl of func.locals) {
                                this.declareVariable(localDecl);
                            }
                        }
                        // Executar corpo e capturar o retorno
                        try {
                            this.executeStatements(func.body);
                        } catch (ret) {
                            if (ret && ret.__portugol_return__) {
                                return ret.value;
                            }
                            throw ret;
                        }
                        // Se não houver retorno, valor padrão 0
                        return 0;
                    } finally {
                        // Restaurar escopo anterior
                        this.env.variables = previousVariables;
                        this.env.refs = previousRefs;
                    }
                }

                // Funções embutidas
                switch (funcName) {
                    case 'abs': return Math.abs(args[0] || 0);
                    case 'quad': return Math.pow(args[0] || 0, 2);
                    case 'raizq': return Math.sqrt(args[0] || 0);
                    case 'exp': return Math.exp(args[0] || 0);
                    case 'ln': return Math.log(args[0] || 0);
                    case 'log': return Math.log10(args[0] || 0);
                    case 'pi': return Math.PI;
                    case 'sin': return Math.sin(args[0] || 0);
                    case 'cos': return Math.cos(args[0] || 0);
                    case 'tan': return Math.tan(args[0] || 0);
                    case 'arccos': return Math.acos(Math.max(-1, Math.min(1, args[0] || 0)));
                    case 'arcsen': return Math.asin(Math.max(-1, Math.min(1, args[0] || 0)));
                    case 'arctan': return Math.atan(args[0] || 0);
                    case 'cotan': {
                        const tanValue = Math.tan(args[0] || 0);
                        if (Math.abs(tanValue) < 1e-15) return Infinity;
                        return 1 / tanValue;
                    }
                    case 'grauprad': return (args[0] || 0) * Math.PI / 180;
                    case 'radpgrau': return (args[0] || 0) * 180 / Math.PI;
                    case 'logn': return Math.log(args[0] || 0);
                    case 'rand': return Math.random();
                    case 'randi': return Math.floor(Math.random() * (args[0] || 100));
                    case 'compr': return String(args[0] || '').length;
                    case 'maiusc': return String(args[0] || '').toUpperCase();
                    case 'minusc': return String(args[0] || '').toLowerCase();
                    case 'asc': return String(args[0] || '').charCodeAt(0) || 0;
                    case 'carac': return String.fromCharCode(args[0] || 65);
                    case 'caracpnum': return parseFloat(String(args[0] || '0').replace(',', '.')) || 0;
                    case 'copia': {
                        const str = String(args[0] || '');
                        const pos = (args[1] || 1) - 1; // VisualG usa indexação baseada em 1
                        const len = args[2] || str.length;
                        return str.substring(pos, pos + len);
                    }
                    case 'numpcarac': return String(args[0] || '');
                    case 'pos': {
                        const haystack = String(args[1] || '');
                        const needle = String(args[0] || '');
                        const index = haystack.indexOf(needle);
                        return index >= 0 ? index + 1 : 0; // VisualG usa indexação baseada em 1
                    }
                    default:
                        return 0;
                }
            }

            evaluateArithmetic(expr) {
                // Avaliação aritmética aprimorada para melhor compatibilidade com Portugol
                try {
                    let jsExpr = expr.trim();

                    // Resolver chamadas de função dentro da expressão avaliando primeiro as mais internas
                    const isIdentChar = (ch) => /[a-zA-Z0-9_]/.test(ch);
                    const resolveFunctionCalls = (s) => {
                        let str = s;
                        while (true) {
                            let replaced = false;
                            for (let i = 0; i < str.length; i++) {
                                if (str[i] === '(') {
                                    // Encontrar o identificador antes de '('
                                    let j = i - 1;
                                    while (j >= 0 && str[j] === ' ') j--;
                                    let end = j;
                                    while (j >= 0 && isIdentChar(str[j])) j--;
                                    const name = str.slice(j + 1, end + 1);
                                    if (name) {
                                        // Encontrar o ')' correspondente
                                        let depth = 1;
                                        let k = i + 1;
                                        while (k < str.length && depth > 0) {
                                            const ch = str[k];
                                            if (ch === '(') depth++;
                                            else if (ch === ')') depth--;
                                            k++;
                                        }
                                        if (depth === 0) {
                                            const argsSub = str.slice(i + 1, k - 1);
                                            const evaluated = this.evaluateFunctionCall(`${name}(${argsSub})`);
                                            str = str.slice(0, j + 1) + String(evaluated) + str.slice(k);
                                            replaced = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!replaced) break;
                        }
                        return str;
                    };
                    jsExpr = resolveFunctionCalls(jsExpr);

                    // Resolver acessos a vetores como nome[i,j] dentro de expressões
                    const resolveArrayAccesses = (s) => {
                        let str = s;
                        while (true) {
                            let replaced = false;
                            for (let i = 0; i < str.length; i++) {
                                if (str[i] === '[') {
                                    // Encontrar o identificador antes de '['
                                    let j = i - 1;
                                    while (j >= 0 && str[j] === ' ') j--;
                                    let end = j;
                                    while (j >= 0 && isIdentChar(str[j])) j--;
                                    const name = str.slice(j + 1, end + 1);
                                    if (name) {
                                        // Encontrar o ']' correspondente
                                        let depth = 1;
                                        let k = i + 1;
                                        let inString = false;
                                        while (k < str.length && depth > 0) {
                                            const ch = str[k];
                                            if (ch === '"' && str[k - 1] !== '\\') inString = !inString;
                                            if (!inString) {
                                                if (ch === '[') depth++;
                                                else if (ch === ']') depth--;
                                            }
                                            k++;
                                        }
                                        if (depth === 0) {
                                            const inside = str.slice(i + 1, k - 1);
                                            const evaluated = this.evaluateExpression(`${name}[${inside}]`);
                                            str = str.slice(0, j + 1) + String(evaluated) + str.slice(k);
                                            replaced = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!replaced) break;
                        }
                        return str;
                    };
                    jsExpr = resolveArrayAccesses(jsExpr);
                    
                    // Tratar operador de divisão inteira (\)
                    if (jsExpr.includes('\\')) {
                        const parts = jsExpr.split('\\');
                        if (parts.length === 2) {
                            const left = this.evaluateExpression(parts[0].trim());
                            const right = this.evaluateExpression(parts[1].trim());
                            return Math.floor(left / right);
                        }
                    }
                    
                    // Tratar operador de potência (^)
                    if (jsExpr.includes('^') && !jsExpr.includes('xou')) {
                        const parts = jsExpr.split('^');
                        if (parts.length === 2) {
                            const left = this.evaluateExpression(parts[0].trim());
                            const right = this.evaluateExpression(parts[1].trim());
                            return Math.pow(left, right);
                        }
                    }
                    
                    // Tratar operador de módulo (%)
                    if (jsExpr.includes('%')) {
                        const parts = jsExpr.split('%');
                        if (parts.length === 2) {
                            const left = this.evaluateExpression(parts[0].trim());
                            const right = this.evaluateExpression(parts[1].trim());
                            return left % right;
                        }
                    }
                    
                    // Tratar operador XOR (xou)
                    if (jsExpr.toLowerCase().includes('xou')) {
                        const parts = jsExpr.toLowerCase().split('xou');
                        if (parts.length === 2) {
                            const left = this.isTruthy(this.evaluateExpression(parts[0].trim()));
                            const right = this.isTruthy(this.evaluateExpression(parts[1].trim()));
                            return left !== right;
                        }
                    }

                    // Avaliação padrão do JavaScript para outros operadores
                    jsExpr = jsExpr
                        // constantes e palavras-chave
                        .replace(/\bpi\b/gi, String(Math.PI))
                        .replace(/\bverdadeiro\b/gi, 'true')
                        .replace(/\bfalso\b/gi, 'false')
                        // operadores lógicos (limites de palavra)
                        .replace(/\bmod\b/gi, '%')
                        .replace(/\be\b/gi, '&&')
                        .replace(/\bou\b/gi, '||')
                        .replace(/\bnao\b/gi, '!')
                        // a desigualdade deve ser tratada antes do tratamento genérico de '='
                        .replace(/<>/g, '!=');

                    // Substituir '=' simples por '==' (evitar <=, >=, ==, !=) sem lookbehind (compatível com mais navegadores)
                    {
                        let converted = '';
                        for (let i = 0; i < jsExpr.length; i++) {
                            const ch = jsExpr[i];
                            if (ch === '=') {
                                const prev = i > 0 ? jsExpr[i - 1] : '';
                                const next = i + 1 < jsExpr.length ? jsExpr[i + 1] : '';
                                if (prev !== '<' && prev !== '>' && prev !== '!' && next !== '=') {
                                    converted += '==';
                                    continue;
                                }
                            }
                            converted += ch;
                        }
                        jsExpr = converted;
                    }

                    // Avaliar variáveis
                    for (const [varName] of this.env.variables) {
                        const resolvedVal = this.getVariableValue(varName);
                        if (typeof resolvedVal === 'number' || typeof resolvedVal === 'boolean') {
                            const regex = new RegExp('\\b' + varName + '\\b', 'gi');
                            jsExpr = jsExpr.replace(regex, String(resolvedVal));
                        }
                    }

                    return eval(jsExpr) || 0;
                } catch (error) {
                    if (error && error.__portugol_need_input__) {
                        // Propagar solicitações de entrada interativa durante a avaliação da expressão
                        throw error;
                    }
                    return 0;
                }
            }

            isTruthy(value) {
                if (typeof value === 'boolean') return value;
                if (typeof value === 'number') return value !== 0;
                if (typeof value === 'string') return value.toLowerCase() === 'verdadeiro' || value.toLowerCase() === 'true';
                return Boolean(value);
            }

            // Auxiliares para parâmetros por referência e vetores
            splitTopLevel(str) {
                const expressions = [];
                let current = '';
                let p = 0; // profundidade de parênteses
                let b = 0; // profundidade de colchetes
                let inString = false;
                for (let i = 0; i < str.length; i++) {
                    const ch = str[i];
                    if (ch === '"' && str[i - 1] !== '\\') inString = !inString;
                    if (!inString) {
                        if (ch === '(') p++;
                        else if (ch === ')') p--;
                        else if (ch === '[') b++;
                        else if (ch === ']') b--;
                        else if (ch === ',' && p === 0 && b === 0) {
                            expressions.push(current.trim());
                            current = '';
                            continue;
                        }
                    }
                    current += ch;
                }
                if (current.trim()) expressions.push(current.trim());
                return expressions;
            }

            getVariableValue(varName) {
                const key = this.resolveVariableName(varName);
                if (this.env && this.env.refs && this.env.refs.has(key)) {
                    const ref = this.env.refs.get(key);
                    return ref.map.has(ref.key) ? ref.map.get(ref.key) : 0;
                }
                return this.env.variables.has(key) ? this.env.variables.get(key) : 0;
            }

            setVariableValue(varName, value) {
                const key = this.resolveVariableName(varName);
                if (this.env && this.env.refs && this.env.refs.has(key)) {
                    const ref = this.env.refs.get(key);
                    ref.map.set(ref.key, value);
                } else {
                    this.env.variables.set(key, value);
                }
            }

            getArrayElement(arrayObj, indices) {
                let node = arrayObj;
                for (let d = 0; d < indices.length; d++) {
                    const idx = indices[d];
                    const realIndex = idx - node.startIndex;
                    if (!node || !node.data || realIndex < 0 || realIndex >= node.data.length) return 0;
                    const val = node.data[realIndex];
                    if (d === indices.length - 1) return val;
                    node = val;
                }
                return 0;
            }

            setArrayElement(arrayObj, indices, value) {
                let node = arrayObj;
                for (let d = 0; d < indices.length - 1; d++) {
                    const idx = indices[d];
                    const realIndex = idx - node.startIndex;
                    if (!node || !node.data || realIndex < 0 || realIndex >= node.data.length) return;
                    node = node.data[realIndex];
                }
                const lastIdx = indices[indices.length - 1];
                const realIndex = lastIdx - node.startIndex;
                if (node && node.data && realIndex >= 0 && realIndex < node.data.length) {
                    node.data[realIndex] = value;
                }
            }
        }

        // Implementação de Funções Embutidas
        class PortugolFunctions {
            // Todas as funções embutidas já estão implementadas no interpretador
            // Esta classe pode ser estendida para funcionalidades adicionais
        }

        // Estado da Aplicação e Gerenciamento de UI
        class PortugolCompilerApp {
            constructor() {
                this.parser = new PortugolParser();
                this.interpreter = new PortugolInterpreter();
                this.isRunning = false;
                this.debugMode = false;
                this.editor = null;
                this.baseInputQueue = [];
                this.pendingInputs = [];
                this.lastOutputIndex = 0;
                
                this.initializeUI();
                this.initializeMonaco();
            }

            initializeUI() {
                // Troca de abas
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const tabName = e.target.closest('.tab-button').dataset.tab;
                        this.switchTab(tabName);
                    });
                });

                // Eventos dos botões
                document.getElementById('btn-execute').addEventListener('click', () => this.executeCode());
                document.getElementById('btn-stop').addEventListener('click', () => this.stopExecution());
                document.getElementById('btn-clearCod').addEventListener('click', () => this.clearCode());
                document.getElementById('btn-clear').addEventListener('click', () => this.clearOutput());
                document.getElementById('btn-debug').addEventListener('click', () => this.toggleDebug());
                document.getElementById('btn-example').addEventListener('click', () => this.loadExample());

                // Eventos do modal de entrada
                const overlay = document.getElementById('input-modal');
                const btnCancel = document.getElementById('btn-cancel-input');
                const btnContinue = document.getElementById('btn-continue-input');
                if (btnCancel) btnCancel.addEventListener('click', () => this.hideInputModal());
                if (btnContinue) btnContinue.addEventListener('click', () => this.continueExecutionWithInputs());
                const inputField = document.getElementById('input-modal-value');
                if (inputField) inputField.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.continueExecutionWithInputs();
                    }
                });

                // Inicializar ícones do Lucide
                if (window.lucide) {
                    lucide.createIcons();
                }
            }

            initializeMonaco() {
                require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' } });
                
                require(['vs/editor/editor.main'], () => {
                    // Definir linguagem Portugol
                    monaco.languages.register({ id: 'portugol' });
                    
                    monaco.languages.setMonarchTokensProvider('portugol', {
                        keywords: [
                            'algoritmo', 'fimalgoritmo', 'var', 'inicio', 'se', 'entao', 'senao', 'fimse',
                            'para', 'faca', 'fimpara', 'enquanto', 'fimenquanto', 'repita', 'ate',
                            'funcao', 'fimfuncao', 'procedimento', 'fimprocedimento', 'retorne',
                            'escreva', 'escreval', 'leia', 'interrompa', 'limpatela', 'aleatorio', 'timer', 'pausa', 'debug', 'eco', 'cronometro', 'arquivo',
                            'inteiro', 'real', 'caractere', 'logico', 'vetor', 'de',
                            'verdadeiro', 'falso', 'e', 'ou', 'nao', 'xou', 'mod'
                        ],
                        operators: [
                            '<-', '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '\\', '^', '%'
                        ],
                        symbols: /[<>=!+\-*\/\\^%]+/,
                        
                        tokenizer: {
                            root: [
                                [/[a-zA-Z_][a-zA-Z0-9_]*/, {
                                    cases: {
                                        '@keywords': 'keyword',
                                        '@default': 'identifier'
                                    }
                                }],
                                [/"[^"]*"/, 'string'],
                                [/\d+\.?\d*/, 'number'],
                                [/@symbols/, {
                                    cases: {
                                        '@operators': 'operator',
                                        '@default': ''
                                    }
                                }],
                                [/\/\/.*$/, 'comment'],
                                [/\{[^}]*\}/, 'comment'],
                                [/\s+/, 'white']
                            ]
                        }
                    });

                    // Definir tema
                    monaco.editor.defineTheme('portugol-dark', {
                        base: 'vs-dark',
                        inherit: true,
                        rules: [
                            { token: 'keyword', foreground: '569cd6' },
                            { token: 'string', foreground: 'ce9178' },
                            { token: 'number', foreground: 'b5cea8' },
                            { token: 'comment', foreground: '6a9955' },
                            { token: 'operator', foreground: 'd4d4d4' },
                            { token: 'identifier', foreground: '9cdcfe' }
                        ],
                        colors: {
                            'editor.background': '#1e1e1e',
                            'editor.foreground': '#d4d4d4'
                        }
                    });

                    // Criar editor
                    this.editor = monaco.editor.create(document.getElementById('monaco-container'), {
                        value: this.getDefaultCode(),
                        language: 'portugol',
                        theme: 'portugol-dark',
                        wordWrap: 'on',
                        minimap: { enabled: false },
                        fontSize: 14,
                        lineNumbers: 'on',
                        scrollBeyondLastLine: false,
                        automaticLayout: true,
                        renderWhitespace: 'boundary'
                    });
                });
            }

            getDefaultCode() {
                return `algoritmo "BubbleSort"
var
    i, j, temp: inteiro
    vetor: vetor[1..5] de inteiro
inicio
    vetor[1] <- 5
    vetor[2] <- 3
    vetor[3] <- 4
    vetor[4] <- 1
    vetor[5] <- 2

    para i de 1 ate 4 faca
        para j de 1 ate 5 - i faca
            se vetor[j] > vetor[j+1] entao
                temp <- vetor[j]
                vetor[j] <- vetor[j+1]
                vetor[j+1] <- temp
            fimse
        fimpara
    fimpara

    escreval("Vetor ordenado:")
    para i de 1 ate 5 faca
        escreva(vetor[i], " ")
    fimpara
fimalgoritmo`;
            }

            switchTab(tabName) {
                // Atualizar botões de aba
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

                // Atualizar conteúdo das abas
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`tab-${tabName}`).classList.add('active');
            }

            executeCode() {
                if (!this.editor) return;

                const code = this.editor.getValue();
                // Garantir que a aba de saída esteja visível ao executar
                this.switchTab('output');
                this.setRunning(true);
                this.clearOutput();
                this.lastOutputIndex = 0;

                const startTime = Date.now();

                try {
                    // Analisar o código
                    const parseResult = this.parser.parse(code);
                    
                    if (!parseResult.success || !parseResult.ast) {
                        this.displayErrors(parseResult.errors);
                        this.setRunning(false);
                        return;
                    }

                    if (parseResult.warnings.length > 0) {
                        this.displayWarnings(parseResult.warnings);
                    }

                    // Execução interativa: todas as leituras via popup
                    this.baseInputQueue = [];
                    this.pendingInputs = [];
                    // Reiniciar o índice de renderização da saída para uma nova execução
                    this.lastOutputIndex = 0;
                    let executionResult = this.interpreter.execute(
                        parseResult.ast,
                        {
                            inputQueue: [...this.baseInputQueue, ...this.pendingInputs],
                            interactive: true,
                            requestNextInput: this.requestNextInput.bind(this),
                            debugMode: this.debugMode === true
                        }
                    );
                    if (executionResult.needInput) {
                        this.pendingAst = parseResult.ast;
                        this.pendingPrompt = executionResult.prompt || '';
                        this.pendingVariables = executionResult.variables || [];
                        this.displayOutput(executionResult.output);
                        this.showInputModal(this.pendingVariables, this.pendingPrompt);
                        return;
                    }
                    
                    if (executionResult.success) {
                        // Reconstruir a saída completa após execução interativa bem-sucedida
                        this.lastOutputIndex = 0;
                        this.displayOutput(executionResult.output);
                        this.pendingAst = null;
                    } else {
                        this.displayOutput(executionResult.output);
                        this.displayErrors(executionResult.errors);
                    }
                    
                } catch (error) {
                    this.displayErrors([error.message]);
                } finally {
                    const endTime = Date.now();
                    this.displayExecutionTime(endTime - startTime);
                    if (!this.pendingAst) this.setRunning(false);
                }
            }

            showInputModal(variables = [], prompt = '') {
                // Renderizar entrada inline no container de saída em vez de popup
                const outputContainer = document.getElementById('output-container');
                // Remover entrada inline anterior se existir
                const prev = document.getElementById('inline-input-container');
                if (prev) prev.remove();
                const container = document.createElement('div');
                container.id = 'inline-input-container';
                container.style.marginTop = '8px';
                container.style.display = 'flex';
                container.style.gap = '8px';
                container.style.alignItems = 'center';
                const label = document.createElement('span');
                label.textContent = (variables.length ? `Valor para ${variables.join(', ')}` : 'Valor');
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'inline-input';
                input.style.flex = '1';
                input.placeholder = 'Digite o valor e pressione Enter';
                // Enviar somente com Enter, sem botão
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.continueExecutionWithInputs();
                    }
                });
                container.appendChild(label);
                container.appendChild(input);
                outputContainer.appendChild(container);
                // Garantir que o campo e a última saída estejam visíveis
                outputContainer.scrollTop = outputContainer.scrollHeight;
                input.focus();
            }

            hideInputModal() {
                const inline = document.getElementById('inline-input-container');
                if (inline) inline.remove();
            }

            continueExecutionWithInputs() {
                const field = document.getElementById('inline-input');
                const value = (field?.value || '');
                this.hideInputModal();

                const startTime = Date.now();
                try {
                    this.pendingInputs.push(value);
                    // Confirmar todas as entradas coletadas até agora na fila base e limpar as pendentes
                    this.baseInputQueue = [...this.baseInputQueue, ...this.pendingInputs];
                    this.pendingInputs = [];
                    const executionResult = this.interpreter.execute(
                        this.pendingAst,
                        {
                            inputQueue: [...this.baseInputQueue],
                            interactive: true,
                            requestNextInput: this.requestNextInput.bind(this),
                            debugMode: this.debugMode === true
                        }
                    );
                    if (executionResult.success) {
                        this.displayOutput(executionResult.output);
                        this.pendingAst = null;
                    } else {
                        if (executionResult.needInput) {
                            // Mostra saída parcial e pede próximo valor inline
                            this.displayOutput(executionResult.output);
                            this.pendingPrompt = executionResult.prompt || '';
                            this.pendingVariables = executionResult.variables || [];
                            this.showInputModal(this.pendingVariables, this.pendingPrompt);
                            return;
                        } else {
                            this.displayOutput(executionResult.output);
                            this.displayErrors(executionResult.errors);
                        }
                    }
                } catch (error) {
                    this.displayErrors([error.message]);
                } finally {
                    const endTime = Date.now();
                    this.displayExecutionTime(endTime - startTime);
                    if (!this.pendingAst) this.setRunning(false);
                }
            }

            requestNextInput({ variable, prompt }) {
                // Acionar o modal e pausar lançando um objeto especial que o interpretador irá capturar
                this.pendingVariables = [variable];
                this.pendingPrompt = prompt || '';
                this.showInputModal(this.pendingVariables, this.pendingPrompt);
                throw { __portugol_need_input__: true, variables: [variable], prompt };
            }

            stopExecution() {
                this.setRunning(false);
            }

            clearOutput() {
                const outputContainer = document.getElementById('output-container');
                outputContainer.innerHTML = 'Execute um programa para ver a saída aqui...';
                
                const executionTime = document.getElementById('execution-time');
                executionTime.style.display = 'none';
                this.lastOutputIndex = 0;
            }

            clearCode() {
                if (!this.editor) return;
                this.editor.setValue('');
                this.editor.focus();
                this.setRunning(false);
                this.clearOutput();
            }

            toggleDebug() {
                this.debugMode = !this.debugMode;
                const btn = document.getElementById('btn-debug');
                
                if (this.debugMode) {
                    btn.classList.add('btn-warning');
                    btn.innerHTML = '<i data-lucide="bug"></i> Debug Ativo';
                } else {
                    btn.classList.remove('btn-warning');
                    btn.innerHTML = '<i data-lucide="bug"></i> Debug';
                }
                
                if (window.lucide) {
                    lucide.createIcons();
                }
            }

            loadExample() {
                if (this.editor) {
                    this.editor.setValue(this.getDefaultCode());
                }
            }

            setRunning(running) {
                this.isRunning = running;
                
                const executeBtn = document.getElementById('btn-execute');
                const stopBtn = document.getElementById('btn-stop');
                const status = document.getElementById('status');
                
                if (running) {
                    executeBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-flex';
                    status.textContent = 'Executando...';
                    status.className = 'badge badge-warning';
                } else {
                    executeBtn.style.display = 'inline-flex';
                    stopBtn.style.display = 'none';
                    status.textContent = 'Pronto';
                    status.className = 'badge';
                }
            }

            displayOutput(output) {
                // Sempre mostrar a aba Saída ao renderizar a saída do programa
                this.switchTab('output');
                const outputContainer = document.getElementById('output-container');
                
                // Preservar a entrada inline se presente
                const inlineInput = document.getElementById('inline-input-container');
                let preservedInline = null;
                if (inlineInput) {
                    preservedInline = inlineInput.cloneNode(true);
                }
                
                // Limpar todo o conteúdo anterior e reconstruir a partir da saída fornecida
                outputContainer.innerHTML = '';
                
                if (output.length === 0) {
                    outputContainer.innerHTML = 'Programa executado sem saída.';
                } else {
                    for (let i = 0; i < output.length; i++) {
                        const lineElement = document.createElement('div');
                        lineElement.className = 'success-line';
                        lineElement.textContent = output[i];
                        outputContainer.appendChild(lineElement);
                    }
                }
                
                // Reanexar a entrada inline se ela estava visível
                if (preservedInline) {
                    outputContainer.appendChild(preservedInline);
                }
                
                this.lastOutputIndex = output.length;
                
                // Manter a saída mais recente visível
                outputContainer.scrollTop = outputContainer.scrollHeight;
            }

            displayErrors(errors) {
                // Garantir que os erros estejam visíveis na aba Saída
                this.switchTab('output');
                const outputContainer = document.getElementById('output-container');
                
                errors.forEach(error => {
                    const errorElement = document.createElement('div');
                    errorElement.className = 'error-line';
                    errorElement.textContent = `Erro: ${error}`;
                    outputContainer.appendChild(errorElement);
                });
                // Garantir que os erros estejam visíveis ao usuário
                outputContainer.scrollTop = outputContainer.scrollHeight;
            }

            displayWarnings(warnings) {
                // Garantir que os avisos estejam visíveis na aba Saída
                this.switchTab('output');
                const outputContainer = document.getElementById('output-container');
                
                warnings.forEach(warning => {
                    const warningElement = document.createElement('div');
                    warningElement.style.color = 'var(--editor-warning)';
                    warningElement.textContent = `Aviso: ${warning}`;
                    outputContainer.appendChild(warningElement);
                });
                // Garantir que os avisos estejam visíveis ao usuário
                outputContainer.scrollTop = outputContainer.scrollHeight;
            }

            displayExecutionTime(time) {
                const executionTimeElement = document.getElementById('execution-time');
                executionTimeElement.textContent = `${time}ms`;
                executionTimeElement.style.display = 'inline-block';
            }
        }

        // Inicializar a aplicação quando a página carregar
        document.addEventListener('DOMContentLoaded', () => {
            window.portugolApp = new PortugolCompilerApp();
        });
    </script>
</body>
</html>
